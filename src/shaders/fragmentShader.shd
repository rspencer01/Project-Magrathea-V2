#version 140
in vec4 ShadowCoord;
in vec4 col;
out vec4 FragColor;
in vec2 tex;
in vec4 texShades;
in vec3 normal;
in vec3 camPos;
in vec3 pos;
layout(shared)uniform frameData
{
  vec4 frameColour;  
  mat4x4 transformationMatrix;
  mat4x4 projectionMatrix;  
  mat4x4 lightTransformMatrix;
  mat4x4 lightProjectionMatrix;
  vec4 sunDirection;  
  vec4 cameraPos;
  vec4 fogColour;
  float isShadow;
  float isReflection;
  float sunIntensity;
  float fog;
  float doLighting;
  float cullLevel;
  int gameTime;
  int viewWidth;
  int viewHeight;
};

layout(shared)uniform objectData
{
  mat4x4 objectMatrix;
  vec4 objectColour; 
  float shinyness;  
  // Object type of 1 indicates water
  int objectType;
};
uniform sampler2D shadowTexture;
uniform sampler2D otherTexture;
uniform sampler2D waterTexture;

void main()
{ 
  // Handle water
  if (objectType==1)
  {
    if (isShadow>0.5)
      discard;
    float ambient = 0.2;
    float sunlight = sunIntensity;
    // Get the reflective component
	vec2 screenTexCoord = gl_FragCoord.xy / vec2(viewWidth,viewHeight);
	vec3 flatNormal = vec3(normal.x,0,normal.z);
	vec4 screenOffset = normalize(projectionMatrix * transformationMatrix * vec4(flatNormal,1))*length(flatNormal);
	
	
	vec4 reflectiveFrag = texture(waterTexture,screenTexCoord+screenOffset.xy/20);
    // A color for the texture
	
    vec4 otherTexFrag = texture(otherTexture,tex);

    float vis = 0.6+0*clamp(sunIntensity+ambient,0,1);
  
  
    float spec = 0;
    vec3 incidenceVector = -normalize(sunDirection.xyz);
    vec3 reflectionVector = normalize(reflect(incidenceVector,normal));
    vec3 surfaceToCamera = normalize(cameraPos.xyz - pos);
    spec = pow(max(0,dot(surfaceToCamera,reflectionVector)),1.0/shinyness) *pow(sunlight,0.2);
  
    vis += 0.2*clamp(dot(normal,sunDirection.xyz)*sunIntensity,0,1);
    vis = clamp(vis,0,1);
    //vis += spec;

    float fogLevel = clamp(length(cameraPos.xyz - pos)/fog,0,1);
  
	FragColor =  vec4( vis *reflectiveFrag.xyz * vec3(0.7,1,1),col.w);
	return;
  }
  if (doLighting>0.5)
    if (pos.y<cullLevel+0.05) 
      discard;
  if (isShadow>0.5)
  {
    FragColor = texture(otherTexture,tex);//  texture(otherTexture,tex);//vec4(vec3(gl_FragCoord.z),texture(otherTexture,tex).w);
    return;
  }
  float ambient = 0.2;
  float sunlight = sunIntensity;
  // 16 samples per pixel.
  float diff = 0.8/49.0 * sunlight;
  float shadow = 1;
  
  // Test if point is inside the shadow render area...
  if ((ShadowCoord.x>0  && ShadowCoord.x<1)&&
      (ShadowCoord.y>0  && ShadowCoord.y<1))
  {
    float y,x;
    for (y = -1.5 ; y <=1.5 ; y+=0.5)
      for (x = -1.5 ; x <=1.5 ; x+=0.5)
        if (texture(shadowTexture,ShadowCoord.xy+vec2(x,y)/10000).z < ShadowCoord.z-0.0001)
          shadow -= diff;
  }
  
  // A color for the texture
  vec4 otherTexFrag = vec4(0);
  
  // Determine if the multi-texture mode is disabled
  if (texShades.x<0)
    otherTexFrag = texture(otherTexture,tex);
  // Otherwise, sample the multi-texture.
  else
  {
    otherTexFrag
     += texShades.x * texture(otherTexture,mod(tex,vec2(1.0))/2              );
    otherTexFrag += texShades.y * texture(otherTexture,mod(tex,vec2(1.0))/2+vec2(0  ,0.5));
    otherTexFrag += texShades.z * texture(otherTexture,mod(tex,vec2(1.0))/2+vec2(0.5,0)  );
    otherTexFrag += texShades.w * texture(otherTexture,mod(tex,vec2(1.0))/2+vec2(0.5,0.5));
  }
  

  float vis = 0.2+0*clamp(sunIntensity+ambient,0,1);
  
  
  float spec = 0;
  vec3 incidenceVector = -normalize(sunDirection.xyz);
  vec3 reflectionVector = normalize(reflect(incidenceVector,normal));
  vec3 surfaceToCamera = normalize(cameraPos.xyz - pos);
  spec = pow(max(0,dot(surfaceToCamera,reflectionVector)),1.0/shinyness) *pow(sunlight,0.2);
  
  vis += 0.8*clamp(dot(normal,sunDirection.xyz)*sunIntensity,0,1);
  vis = clamp(vis,0,1);
  vis += spec;

  float fogLevel = clamp(length(cameraPos.xyz - pos)/fog,0,1);
  
  if (objectType==1)
    shadow = 1;
  // The transparancy is taken straight from the texture 
  if (doLighting>0.5)
	FragColor =  vec4(vis * shadow * col.xyz * otherTexFrag.xyz * (1-fogLevel) + fogLevel*fogColour.xyz, col.w * otherTexFrag.w); 
  else
	FragColor =  col * otherTexFrag;
  //FragColor = vec4(normal/2+vec3(0.5),1);
}
