#version 150
#extension GL_EXT_geometry_shader4 : enable

layout(triangles) in;
layout(triangle_strip) out;
layout(max_vertices = 3) out;

in vec4 vsColour[];
in vec2 vsTexcoord[];
in vec4 vsTexShades[];
in vec3 vsNormal[];
in vec3 vsPosition[];

out vec4 gsShadowCoord;
out vec4 gsColour;
out vec2 gsTexcoord;
out vec4 gsTexShades;
out vec3 gsNormal;
out vec3 gsPosition;

layout(shared)uniform frameData
{
  vec4 frameColour;  
  mat4x4 transformationMatrix;
  mat4x4 projectionMatrix;  
  mat4x4 lightTransformMatrix;
  mat4x4 lightProjectionMatrix;
  vec4 sunDirection;  
  vec4 cameraPos;
  vec4 fogColour;
  float isShadow;
  float isReflection;
  float sunIntensity;
  float fog;
  float doLighting;
  float cullLevel;
  int gameTime;
  int viewWidth;
  int viewHeight;
};

layout(shared)uniform objectData
{
  mat4x4 objectMatrix;
  vec4 objectColour; 
  float shinyness;  
  // Object type of 1 indicates water
  int objectType;
};

vec4 mapToTexture(vec4 pos)
{
 return vec4(pos.xyz * 0.5 /pos.w + 0.5,1);
}


void main() 
{
  for (int i = 0; i<3 ; i++)
  {
	gsColour = vsColour[i];
	gsTexcoord = vsTexcoord[i];
	gsTexShades = vsTexShades[i];
	gsNormal = vsNormal[i];
	gsPosition = vsPosition[i];
	gsShadowCoord = mapToTexture(lightProjectionMatrix * lightTransformMatrix * gl_PositionIn[i]);
    if (isShadow>0.5)
      gl_Position = lightProjectionMatrix * lightTransformMatrix * gl_PositionIn[i];
	else
	  gl_Position = projectionMatrix * transformationMatrix * gl_PositionIn[i];
	EmitVertex();
  }
  EndPrimitive();
}
