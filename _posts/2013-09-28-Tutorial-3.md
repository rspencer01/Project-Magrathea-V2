---
layout: post
title: Tutorial 3 - ... Cameras ...
---

Cameras!  Woot!

Wait, what is a camera, and why should you be excited?

Well, a camera is an artificial construct used to describe how the user views the virtual world we are creating.  Most cameras can move around the place and rotate.  In many "First-Person" games, the camera is placed where the avatar's head would be so that it seems that you see the world throught their eyes.  In others, the camera follows the main character.  You get the picture.

Lets define a `Camera` class (in corresponding `camera.cpp` and `camera.h`) with the following declaration.

{% highlight cpp %}
class Camera
{
  private:
    Vector3 Position;
    Vector3 UpVector;
    Vector3 ViewDir;
  public:
    Camera();				
    void Render ( void );							
    void Move ( Vector3 Direction );
    void RotateX ( float Angle );
    void RotateY ( float Angle );
    void RotateZ ( float Angle );
    void MoveForward ( float Distance );
};
{% endhighlight %}

Go ahead and fill in some of the easy functions, such as the constructor (sets the position to `<-5,0,0>` and `ViewDir` to `<1,0,0>` and `UpVector` to `<0,1,0>`).

Note how the `Vector3` class comes in handy here.  I should probably mention what `UpVector` and `ViewDir` are.  Obviously `Position` is the location of the camera in three-D space.  `ViewDir` encodes the direction that the camera is pointing.  Thus a `ViewDir` of `<1,0,0>` corresponds to looking in the positive x direction.

`UpVector` is a vector that should be perpendicular to `ViewDir` at all times.  It encodes how to rotate the camera: which way is "up".  This becomes non-trivial when we start to look at the ground or the sky.  The initial values given two paragraphs ago correspond to being 5 units from the origin, looking int the positive x direction, with "upwards" being the positive y direction.

The `MoveForward` function is also easy.  We will most probably want to move in the direction we are facing, so go ahead and add the distance multiplied by our `ViewDir` to the `Position` in that function.  `Move` is also fairly easy (but not 100% required: its just good to have, in case).

The rotate functions are best done with an example.  In most cases, the `rightDir` vector is useful.  This is a vector pointing to the right.  It is found by crossing the `ViewDir` with `UpVector`.

{% highlight cpp %}
Vector3 rightDir = ViewDir.cross(UpVector).normal();
{% endhightlight %}

Then if, for example, we are rotating in the vertical axis, we can write

{% highlight cpp %}
ViewDir = ViewDir*cos(theta) + UpVector*sin(theta);
{% endihighlight %}

If you are unsure what should be where with the trigonometric functions, check out the source, at the end of this tutorial.

Finally, the `Render` function.  Remember that nice function `gluLookAt`?)Here we will use it again.

{% highlight cpp %}
void Camera::Render()
{
  Vector3 LookAtPosition = Position+ViewDir;
  gluLookAt(Position.x,Position.y,Position.z,
            LookAtPosition.x,LookAtPosition.y,LookAtPosition.z,
            UpVector.x,UpVector.y,UpVector.z);
}
{% endhighlight %}

So, just call `Camera::Render` before rendering your scene and voila!  It shows it from that location.
