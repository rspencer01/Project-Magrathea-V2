---
layout: post
title: Tutorial 2 - Tea for one!
---

So last time we constructed an empty scene of a red background.  Today we will put something into that scene, as well as develop some frameworks for viewing it from different angles (but that will actually be the meat of the next tutorial).

The first step is to develop a `Vector3` class.  This will be used often, so it is worth spending some time on it, to make it as complete as possible.  We are doing it here, as it is a useful thing to do early on, even though we only use it next time.  

The implimentation of this class is left up to the reader, but here is a suggested class declaration:

{% highlight cpp %}
class Vector3
{
  public:
    float x;
    float y;
    float z;
    Vector3(float x,float y,float z);
    Vector3();
    Vector3 operator=(const Vector3&);
    Vector3 operator+(Vector3);
    Vector3 operator-(Vector3);
    Vector3 operator*(float);
    Vector3 operator/(float);
    void normalise();
    float dot(Vector3);
    Vector3 cross(Vector3);
    float magnitude();
    Vector3 normal();
};
{% endhighlight %}

The dot and cross are the scalar and vector products respectively.  These are very useful for getting perpendicular vectors and projections respectively.  If you are not familiar with vector algebra, now would be a good time to do some [lookup][1].  It will also be imperitive to learn about matrices.  The first three pages of [this][2] should be enough.

There is one basic method missing from the last tutorial, that of the `resize`.  When the window changes size, some operations must be done to make sure that OpenGl renders to the entire window.  This prompts a reorganisation of the graphics functions.  

Lets make a `graphics.cpp` (and corresponding `graphics.h`) to hold our graphics related functions.  Define `initGraphics` and call it from within `Game` (this function does everything `Game::Game` did, except the last two lines).

In the same file, we can have the function `void resize(int,int)` that looks as follows

{% highlight cpp %}
void resize(int width, int height)
{
  glViewport(0,0,(GLsizei)width,(GLsizei)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  // Arguments are: Field of view, Aspect ratio, Near and then far plane
  gluPerspective(60,(GLfloat)width/(GLfloat)height,1.0,1500);
  glMatrixMode(GL_MODELVIEW);
}
{% endhighlight %}

This prompts a bit of explanation.

The first line tells OpenGL to render to a box with bottom left corner at 0,0 and top right at the size of the window size (width and height are passed from GLUT).  This ensures that the whole window is rendered.

The second line is similar to the last line.  It tells OpenGL that whatever we do from now on will edit the `GL_PROJECTION` matrix.  There are a lot of different matrices in OpenGL, they are, after all the way that your GPU edits points.  Matrices allow easy translation and rotation of points.

Line 2 tells OpenGL that we will be editing the matrix which transforms how the scene is projected, [orthographic][3] or [perspective][4].  Don't worry about the maths in the second link.  We will get there eventually

Fortunately we don't have to worry too much about what is in those matrices, as `gluPerspective` does it all for us.  The arguments are commented in the code.  The near plane is the distance closer than which objects are not rendered, and vice versa for the far plane.

The last line puts us back in `GL_MODELVIEW` mode: any changes we make to the matrix will now be manifest in how the model (scene) is transformed.  (To be specific, the MODELVIEW matrix is applied to every point, and then the PROJECTION matrix is).

Now let us modify the `Game::Render` function to do something interesting.  After `glClearColor` put

{% highlight cpp %}
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
      
gluLookAt(0,0,3,0,0,0,0,1,0);
        
glutWireTeapot(1);
{% endhighlight %}

The first three lines set up the `MODELVIEW` matrix so that it transforms the points given to it to somthing that looks as it would, if viewed from a camera at position `<0,0,3>` (first 3 arguments), looking at `<0,0,0>` (ie back towards the origin) with the up direction being `<0,1,0>`.  Bear in mind that this is a convention we are assuming (that y is the up direction).

Finally the last line... draws a teapot (of size 1).  Run this code and you should get this
![](http://rspencer01.github.io/Project-Magrathea-V2/assets/Screenshot2.png)

[1]: http://www.mathsisfun.com/algebra/vectors.html
[2]: http://www.sosmath.com/matrix/matrix.html
[3]: http://www.technologystudent.com/designpro/ortho1.htm
[4]: http://www.scratchapixel.com/lessons/3d-advanced-lessons/perspective-and-orthographic-projection-matrix/perspective-projection-matrix/
