---
layout: post
title: Tutorial 1 - Hello Big World!
---

Welcome to the first in a series of tutorials about how to roll your own world.  This series will be part theory, part practice with it getting more theoretical as time goes on.  There _will_ be code to start with but as the sytem progresses, most of the discussion will tend towards general techniques and practices.

These pages are pitched to people with little to no OpenGL programming experience at all, but who have a solid understanding and working knowledge of c++, and will go from the basics, showing one style.  There are others, and for a full view of OpenGL programming, one should consult other tutorials as well.

I will brush over some things.  If there is something you would like to know more about, Google should be your first stop.  There are many (better) tutorials about OpenGL out there, and some of them may explain concepts better than I do.

Enough meta stuff, lets get cracking.

This tutorial is all about getting a helloworld screen like this:
![](http://rspencer01.github.io/Project-Magrathea-V2/assets/Screenshot1.png)

Yeah.  A red screen.  Still.  Its better than nothing.

Firstly, some terminology.  According to Wikipedia, _"**OpenGL (Open Graphics Library)** is a cross-language, multi-platform application programming interface (API) for rendering 2D and 3D computer graphics."_  In other words, its a set of functions for doing visual stuff.

**GLUT (OpenGL Utility Toolkit)**, or freeGLUT, is the library that handles interaction with the operating system, managing windows, mouse io and keyboards.

**GLEW (OpenGL Extension Wrangler)** is a library that helps load OpenGL extensions.

You will notice that the image above is taken from a GNU/Linux machine (Ubuntu to be precise), but a lot of my development has been in Windows.  The cool thing about freeglut and glew is that there are versions for Windows and GNU/Linux.  The only problems I have found so far have been different versions of OpenGL, but that is another story.

So to start we will need freeglut and glew.  These are downloadable [here][1] and [here][2], from which you should follow the instructions on the web.  In a linux box one can run

    {% highlight bash %}
    $ sudo apt-get install freeglut3-dev libglew1.6-dev {% endhighlight %}

Right.  Now lets get coding.  Firstly lets take a look at the directory structure I suggest.

    magrathea
    +-- src
    |   +-- include
    |   |   +-- magrathea.h
    |   |   +-- game.h
    |   |   `-- ...
    |   +-- Makefile
    |   +-- main.cpp
    |   +-- game.cpp
    |   `-- ...
    +-- .gitignore 
    `-- README.md
        
All the header files are stored in `src/include`, and all the source is stored in `src`.  The items in the root file are there for github and documentation.

If you are unfamiliar with makefiles, I suggest you go and [look them up][3].  They are very useful.  Ours is simple.

    {% highlight make linenos=table%}
    # The g++ compiler.
    CC = g++
    # Flags passed to the compiler
    CFLAGS = -c -Wall -Werror
    IDIR = include
    ODIR = obj
    SRCS = main.cpp gameops.cpp vector3.cpp graphics.cpp heightmap.cpp
    _OBJS = $(SRCS:.cpp=.o)
    OBJS = $(patsubst %,$(ODIR)/%,$(_OBJS))
    EXEC = magrathea
    LIBS = -lglut -lGLU 

    all: $(ODIR) $(OBJS) $(EXEC)

    $(ODIR):
        mkdir $(ODIR)

    $(EXEC): $(OBJS)
        $(CC) $(OBJS) $(LIBS) -o $(EXEC)

    $(ODIR)/%.o: %.cpp $(DEPS)
        $(CC) -I $(IDIR) $(CFLAGS) -o $@ $<

    clean:
        rm -r $(ODIR)
        rm $(EXEC){% endhighlight %}

Also note the .gitignore.  Once again, if you are unfamiliar with git, I suggest you go and read up a bit about it.  It is not a requirement, but it does make things nice.  

Now, lets define a class `Game` in `include/game.h`.  It will have a constructor and a function called `run` that takes no arguments.  Both of these should be public.

Our `main.cpp` will hold the entry to the program, `main(int,char**)` (doh), and will look as follows:

    {% highlight cpp linenos=table%}
    int main(int argc, char** argv)
    {
        Game mainGame;
        mainGame.run();
        return 0;
    }{% endhighlight %}

We construct a game and run it. Reason for this is that later on we might want to do other things with the game apart from running it, so this would be the place to do that.  All functions related to the actual display etc are stored in `Game`.

In `game.cpp`, we will create the game as follows.  Note that `glutInit` expects the program arguments and argument count.  Here we fabricate some, because passing them to the `Game` constructor is unneccessary at this point.

    {% highlight cpp linenos=table%}
    Game::Game()
    {
      // Fabricate some args
      int argc = 0;
      char arg[10] =  "magrathea";
      char** argv = (char**)&arg;
      // Init glut with these argument values
      glutInit(&argc,argv);
      // This tells glut that we want RGBA colours
      glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA);
      // A begginning window size and position.  This will eventualy be full screen
      glutInitWindowSize(500,500);
      glutInitWindowPosition(100,100);
      glutCreateWindow("Magrathea");
      // What functions should glut call?
      glutDisplayFunc(displayCurrentGame);
      currentGame = this;
    }{% endhighlight %}

But what are these `currentGame` and `displayCurrentGame`?  Well, when GLUT wants to display something, it calls whatever argument you pass to `glutDisplayFunc`.  However this needs to be a static function, so we define, in `game.cpp`, above `Game::Game`

    {% highlight cpp linenos=table%}
    Game* currentGame;
    void displayCurrentGame()
    {
      currentGame->display();
    }{% endhighlight %}

All great, right?  Not quite.  We still don't know what `Game::display()` does.  That is easy.  Declare `display` as a public function of `Game`, and define

    {% highlight cpp linenos=table%}
    void Game::display()
    {
      glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
      glClearColor(1,0,0,0.5);
      glutSwapBuffers();
    }{% endhighlight %}

The first line resets the buffer (more on this in later tutorials), the second makes the screen red, and the third actually puts it to the screen.  (If you are a first time OpenGL programmer, stop here.  Go look at some other tutorials, for a more complete Helloworld example.)

Finally the run function is really simple.  Glut has a main loop (from which it calls the `display` function), and to enter it, we simply do

    {% highlight cpp linenos=table %}
    void Game::run()
    {
      glutMainLoop();
    }{% endhighlight %}

And that is it!  Compile with `make` and run it.  A red box should appear on your screen and the program should terminate when it is closed.  Great!

Next time: A teapot and a camera.

[1]: http://freeglut.sourceforge.net/
[2]: http://glew.sourceforge.net/install.html
[3]: http://mrbook.org/tutorials/make/
